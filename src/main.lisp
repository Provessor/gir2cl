(defpackage gir2cl
  (:use :cl)
  (:import-from #:cxml)
  (:import-from #:gir)
  (:import-from #:kebab)
  (:import-from #:simple-date-time)
  (:export
   #:generate))
(in-package :gir2cl)

;; repository
;; |- include
;; |- package
;; |- namespace
;; |-+
;; | |- class
;; | |-+
;; | | |- source-position
;; | | |- method
;; | | |-+
;; | | | |- source-position
;; | | | |- return-value
;; | | | |- parameters
;; | | | |-+
;; | | | | |- instance-parameter
;; | | | | |-+
;; | | | | | |- doc
;; | | | | | |- type
;; | | | | |- parameter
;; | | | | |-+
;; | | | | | |- doc
;; | | | | | |- type

(defun generate (package-name namespace stream gir-pathname)
  "Generates low-level Common Lisp bindings from the GIR filepath
passed in. Returns a list of exported symbols."
  (check-type package-name string)
  (check-type gir-pathname pathname)
  (check-type stream (or stream boolean))

  (let ((*package* (find-package :cl-user))
        (handler (make-instance 'gir-handler :namespace namespace :output-stream stream)))
    (format stream ";;;; Generated by gir2cl on ~a~%~%" (simple-date-time:rfc-2822
                                                         (simple-date-time:now)))
    (format stream "(in-package ~a)~%~%" package-name)
    (format stream "(defparameter *ns* (gir:require-namespace \"~@*~a\"))~%~%"
            namespace)
    (format stream "~(~s~)~%~%"
            '(defclass cl-user::gir-object ()
              ((cl-user::native-pointer :initarg :native-pointer :reader cl-user::native-pointer))))
    (cxml:parse-file gir-pathname handler)
    (cons 'cl-user::gir-object (cons 'cl-user::native-pointer (reverse (all-symbols handler))))))

(defclass gir-class ()
  ((name :type symbol
         :initarg :name
         :reader name)
   (gir-name :type string
             :initarg :gir-name
             :reader gir-name)
   (slots :type list
          :initform (list)
          :accessor slots)
   (parent-clos-class :type symbol
                      :initarg :parent-clos-class
                      :initform nil)
   (constructors :type list
                 :initform (list)
                 :accessor constructors)
   (methods :type list
            :initform (list)
            :accessor methods)))

(defmethod print-object ((class gir-class) stream)
  (with-slots (name slots parent-clos-class)
      class
    (format
     stream
     "~(~s~)"
     `(defclass ,name ,(if parent-clos-class
                           (list parent-clos-class)
                           '(cl-user::gir-object))
        (,@slots)))))

(defclass gir-method ()
  ((name :type symbol
         :initarg :name
         :reader name)
   (gir-name :type string
             :initarg :gir-name)
   (class-name :type string
               :initarg :class-name)
   (parameters :type list
               :initform (list)
               :accessor parameters)))

(defmethod print-object ((method gir-method) stream)
  (with-slots (name gir-name class-name parameters)
      method
    (let ((parameters (reverse parameters)))
      (format
       stream
       "~(~s~)"
       `(defmethod ,name ((,class-name ,class-name) ,@parameters)
          (with-slots (cl-user::native-pointer)
              ,class-name
            (gir:invoke (cl-user::native-pointer ,gir-name) ,@parameters)))))))

(defclass gir-function ()
  ((clos-class-name :type symbol
                    :initarg :clos-class-name)
   (gir-class-name :type string
                   :initarg :gir-class-name)
   (name :type symbol
         :initarg :name)
   (gir-name :type string
             :initarg :gir-name)
   (parameters :type list
               :initform (list)
               :accessor parameters)))

(defmethod name-symbol ((function gir-function))
  "Generates a symbol for the name of the constructor."
  (with-slots (clos-class-name name)
      function
    (intern (format nil "~:@(make-~a-~s~)" clos-class-name name))))

(defmethod print-object ((function gir-function) stream)
  (with-slots (clos-class-name gir-class-name gir-name parameters)
      function
    (let ((parameters (reverse parameters)))
      ;; First format is to inject the GIR class name in its proper
      ;; case. The second is to print the lisp bits in lowercase.
      (format
       stream
       (format
        nil
        "~(~s~)"
        `(defun ,(name-symbol function) (,@parameters)
           (let ((cl-user::pointer (gir:invoke (cl-user::*ns* "~a" ,gir-name) ,@parameters)))
             (make-instance ',clos-class-name :native-pointer cl-user::pointer))))
       gir-class-name))))

(defclass gir-parameter ()
  ((name :type string
         :initarg :name
         :reader name)
   (type :type type
         :initarg :type
         :initform nil
         :accessor gir-type)))

(defmethod print-object ((parameter gir-parameter) stream)
  (with-slots (name)
      parameter
    (format stream "~(~a~)" name)))

(defclass gir-enumeration ()
  ((namespace :type symbol
              :initarg :namespace
              :initform (error ":symbol is required.")
              :reader namespace)
   (name :type string
         :initarg :name
         :reader name)
   (members :type list
            :initform (list)
            :accessor members)))

(defmethod print-object ((enumeration gir-enumeration) stream)
  (loop with namespace = (namespace enumeration)
        with enumeration-name = (name enumeration)
        for member in (members enumeration)
        ;; Must be upcase so that it's not interned as case-sensitive
        ;; symbols.
        for name-upcase = (string-upcase (name member))
        for name-global = (global-symbol-from member)
        for name-keyword = (intern name-upcase :keyword)
        for defparam-form = `(defparameter ,name-global
                               (gir:nget ,namespace "~a" ,name-keyword))
        do (format stream (format nil "~(~s~)~%" defparam-form) enumeration-name)))

(defclass gir-enumeration-member ()
  ((enum-name :type string
              :initarg :enum-name
              :initform (error ":enum-name is required")
              :reader enum-name)
   (name :type string
         :initarg :name
         :initform (error ":name is required.")
         :reader name)))

(defmethod global-symbol-from ((enum-member gir-enumeration-member))
  (intern (format nil "*~a-~a*"
                  (string-upcase (kebab:to-kebab-case (enum-name enum-member)))
                  (string-upcase (kebab:to-kebab-case (name enum-member))))))

(defclass gir-handler (sax:default-handler)
  ((namespace :type string
              :initarg :namespace
              :initform (error "namespace must be specified.")
              :reader namespace)
   (clos-from-gir :type hash-table
                  :initform (make-hash-table :test #'equalp)
                  :accessor clos-from-gir)
   (output-stream :type stream
                  :initarg :output-stream
                  :initform (error "output-stream must be specified.")
                  :reader output-stream)
   (current-class :type gir-class
                  :initform nil
                  :accessor current-class)
   (current-constructor :type gir-class
                        :initform nil
                        :accessor current-constructor)
   (current-method :type gir-method
                   :initform nil
                   :accessor current-method)
   (current-parameter :type gir-parameter
                      :initform nil
                      :accessor current-parameter)
   (current-enumeration :type gir-enumeration
                        :initform nil
                        :accessor current-enumeration)
   (current-enumeration-member :type gir-enumeration-member
                               :initform nil
                               :accessor current-enumeration-member)

   (all-symbols :type list
                :initform (list)
                :accessor all-symbols
                :documentation
                "A list of all symbols that are generated.")))

(defmethod sax:start-element ((handler gir-handler) namespace-uri local-name qname attributes)
  ;; All of the logic for skipping XML nodes of certain types should
  ;; be centralized here. By doing this, the logic in `end-element`
  ;; only need check to see if an instance of instantiated.
  (flet ((element-attr (attr-name)
           (sax:attribute-value
            (find attr-name attributes :key #'sax:attribute-local-name :test #'string=))))
    (cond
      ((string= local-name "class")
       (let* ((name (element-attr "name"))
              (parent (element-attr "parent"))
              (shadowed (find-symbol (string-upcase (kebab:to-kebab-case name))))
              (acceptable-name (kebab-symbol-from-string
                                (if shadowed (concatenate 'string (namespace handler) name) name)))
              (class (make-instance 'gir-class
                                    :name acceptable-name
                                    :gir-name name
                                    :parent-clos-class (gethash parent (clos-from-gir handler)))))
         (setf (gethash name (clos-from-gir handler)) acceptable-name
               (current-class handler) class)))

      ((and (string= local-name "constructor")
            ;; Only constructors within classes are currently
            ;; supported.
            (current-class handler))
       (let* ((name (element-attr "name"))
              (constructor (make-instance 'gir-function
                                          :name (kebab-symbol-from-string name)
                                          :gir-name name
                                          :clos-class-name (name (current-class handler))
                                          :gir-class-name (gir-name (current-class handler)))))
         (setf (current-constructor handler) constructor)))

      ((string= local-name "enumeration")
       (setf (current-enumeration handler)
             (make-instance 'gir-enumeration
                            :name (element-attr "name")
                            :namespace 'cl-user::*ns*)))

      ((and (string= local-name "member")
            (current-enumeration handler))
       (setf (current-enumeration-member handler)
             (make-instance 'gir-enumeration-member
                            :enum-name (name (current-enumeration handler))
                            :name (element-attr "name"))))

      ((and (string= local-name "method")
            ;; Only methods within classes are currently supported.
            (current-class handler))
       (let* ((name (element-attr "name"))
              (class-namespaced-name (format nil "~(~a-~a~)"
                                             (name (current-class handler))
                                             name))
              (shadowed (find-symbol (string-upcase (kebab:to-kebab-case class-namespaced-name))))
              (acceptable-name (kebab-symbol-from-string
                                (if shadowed
                                    (concatenate 'string (namespace handler) class-namespaced-name)
                                    class-namespaced-name)))
              (method (make-instance 'gir-method
                                     :name acceptable-name
                                     :gir-name name
                                     :class-name (name (current-class handler)))))
         (setf (current-method handler) method)))

      ((and (string= local-name "parameter")
            (or (current-method handler)
                (current-constructor handler))
            ;; The cl-gobject-introspection library handles passing the
            ;; length of sequences for us. Don't include the parameter
            ;; in our bindings.
            (not (length-parameter-p handler)))
       (let* ((name (element-attr "name"))
              (parameter (make-instance 'gir-parameter :name (kebab-symbol-from-string name))))
         (setf (current-parameter handler) parameter)))

      ((and (string= local-name "array")
            (current-parameter handler))
       ;; For array parameters, we need only know that they are arrays
       ;; so that we can ellide the subsequent length parameter.
       (setf (gir-type (current-parameter handler)) 'array)))))

(defmethod sax:end-element ((handler gir-handler) namespace-uri local-name qname)
  ;; Before processing a element when exiting its XML node, first
  ;; check that the handler has instantiated an instance for the
  ;; elment. There are conditionals which may cause the handler to
  ;; bypass certain elements.
  (with-accessors ((out output-stream)
                   (class current-class)
                   (all-symbols all-symbols)
                   (ctor current-constructor)
                   (param current-parameter)
                   (method current-method)
                   (enum current-enumeration)
                   (enum-member current-enumeration-member))
      handler
    (cond
      ((string= local-name "class")
       (format out "~a~%~%" class)
       (dolist (c (reverse (constructors class)))
         (format out "~a~%~%" c))
       (dolist (m (reverse (methods class)))
         (format out "~a~%~%" m))
       (setf all-symbols (cons (name class) all-symbols)
             class nil))

      ((and (string= local-name "constructor") ctor)
       (dolist (p (parameters ctor))
         (pushnew p (slots class) :key #'name :test #'string=))
       (pushnew ctor (constructors class))
       (setf all-symbols (cons (name-symbol ctor) all-symbols)
             ctor nil))

      ((and (string= local-name "method") method)
       (pushnew method (methods class))
       (setf all-symbols (cons (name method) all-symbols)
             method nil))

      ((and (string= local-name "parameter") param)
       (if method
           (pushnew param (parameters method))
           (pushnew param (parameters ctor)))
       (setf param nil))

      ((and (string= local-name "member") enum enum-member)
       (pushnew enum-member (members enum))
       (setf all-symbols (cons (global-symbol-from enum-member) all-symbols)
             enum-member nil))

      ((string= local-name "enumeration") enum
       (format out "~a~%~%" enum)
       (setf enum nil)))))

(defun length-parameter-p (handler)
  "Determines whether this parameter is meant to contain the length of
the previous parameter."
  ;; TODO(katco): How does the gir lib check this, and can we use that here?
  (let* ((current-obj (or (current-method handler) (current-constructor handler)))
         (last-param (when current-obj (car (parameters current-obj)))))
    (if last-param
        (eq (gir-type last-param) 'array)
        nil)))

(defun kebab-symbol-from-string (s)
  (check-type s string)
  (intern (string-upcase (kebab:to-kebab-case s))))
